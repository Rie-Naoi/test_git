# Git もう怖くないGit！チーム開発で必要なGitを完全マスター

## 01 はじめに、コースについて

### このコースの目的

- バージョン管理は何のためにやるのか
- コアコンセプトは？
- どのような仕組みで管理しているのか？
- コミットの裏側ではどんなことがおきているのか？
- 誤った変更を元に戻すには？
- ブランチやマージの運用方法
- コンフリクトの解消方法
- リベースとは？
- 変更内容を一時的に避難させる方法
- GitHubを用いてのチーム開発の進め方

---

## 02 なんのために使うのか

### 何のために使うのか？→バージョンを管理するため

管理しなかった場合、最新のファイルがどれかわからなくなってしまう  
1人で管理ならいいが複数人だとわからなくなってしまう  
管理をすれば、いつ・誰が・何を変更したかもわかるようになる  
上書きしようとすると警告が出る  

---

## 03 Gitの歴史

リーナス・トーバルズ  
<https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%8A%E3%82%B9%E3%83%BB%E3%83%88%E3%83%BC%E3%83%90%E3%83%AB%E3%82%BA>  
Linuxを作った人  
Linuxカーネル開発で利用していたバージョン管理システムのライセンスが変更されしようできなくなった  
既存のソフトで管理できるものがなかった  
2005年頃、Gitの原型となるプログラムの開発が開始された  
他のソフトだと、ブランチを切ったりマージしたりするのに時間がかかった  
開発を迅速に行えるように開発された  

- スピード
- シンプルな設計
- ブランチが並列で開発可能
- 大規模プロジェクトを効率的に取り扱える

---

## 04 GitHubってなんなのか

Chris Wanstrathが友達とコードをシェアしやすいものを作った  
オンライン上でコードの変更内容を預かってくれる  

### 特徴

- プルリクエストによる複数人開発ができる
- 世界中のチームがGitHub上で開発している
- オープンソース開発がしやすくなった

### Gitリポジトリのホスティングサービス

- GitHub 非公開は有料、公開は無料
- Bitbucket 非公開が無料、スモールチームでの非公開プロジェクト向き

---

## 05 コースを受講するにあたって

補足説明テキストベース

>セクション02と03は、さらっと進めて問題ないぐらい昨日の勉強した内容が頭に入っているといいな（感想）

---

## 06 Gitのインストール（MacOS）

### インストール

デフォでGitが入っている。
ターミナルから確認できる。

>講座で使われているiTerm2を入れてみた  
→色がついてわかりやすい  
<https://webrandum.net/iterm2/>

### Gui

- Git GUI / ターミナルでgit guiと打つと開く
- Souecetree / 使ったこあとある。アトラシアンのやつだ。
  <https://www.sourcetreeapp.com/>
- GitKraken / 渡辺さんが教えてくれたやつだ。Udemy終わったら入れてみよう
  <https://www.gitkraken.com/>

>GUIの画面はこの講座が終わったら触ってみる

---

## 07 Gitのインストール（Win）

>私が利用している環境はMacなので今回は聞き流す  
問題があれば、gitのサイトで確認すれば良いと思われる

---

## 08 Atomのインストール（Mac）

>すでにインストールしてあって利用しているが、  
渡辺さんからvscodeがおすすめということでそれも入れてみることにする  
<https://eng-entrance.com/texteditor-vscode>  
ここに書かれている手順で入れてみる  
→すでに入っていた笑  
→atomからvscodeへ編集移動  
→日本語化へ設定変更  
→マークダウン拡張設定  
<https://qiita.com/kumapo0313/items/a59df3d74a7eaaaf3137>  
→環境構築完了！拡張子をtxtからmdに変更した  
まだマークダウン形式ですべてかけてはいないが  

---

## 09 Atomのインストール（win）

>ウィンドウズでは設定しないため、ここは読み飛ばすが、マークダウン方式に拡張子を変更したところ、エラーをたくさんはいたので修正しておく  
2020/03/06：昨日の復習で一回pushしてみる

---

## 10 GitHubの登録

>すでに登録しているのでさらっと映像みて終わりにする  
リスト表記にこのファイルを書き直した

---

## 11 Gitの初期設定

>これも設定終わっているので映像流してみる  
復習のため、以下コードを記載しておく

- ユーザー名の登録

    ```bash
    $git config --global user.name "***"
    ```

- メールアドレスの登録

    ```bash
    $git config --global user.email "**@**.com"
    ```

- デフォルトコードエディタの登録（VSCode)

    ```bash
    $git congig --global core.editor 'code --wait'
    ```

    設定がもう少し必要な模様（2020/03/11)  
    GitのデフォルトエディタをVisual Studio Codeに設定  
    <https://qiita.com/laughingman/items/3cce0effa0c9df8c00ad>

- ユーザー名の確認

    ```bash
    $git config user.name
    ```

- メールアドレスの確認

    ```bash
    $git config user.email
    ```

- デフォルトコードエディタの確認

    ```bash
    $git config core.editor
    ```

- 一度に確認したい場合

    ```bash
    $git config --list
    ```

- みやすく表示できる（ファイルの内容を表示する）

    ```bash
    $cat ~/.gitconfig
    ```

---

## 12 ターミナルの搬出コマンド

テキストだけ記載のセッション

コマンド | 内容
:--- | :---
cd | ディレクトリを移動
ls | ディレクトリの内容を表示
ls-a | 隠しファイルを含めたディレクトリ全内容を表示
mkdir | ディレクトリを新規作成
rm | ファイルを削除
cp | ファイルをコピー
mv | ファイルの移動とファイル名の変更
cat | ファイルの中身を表示

---

## 13 Gitの基本的な仕組みをしろう

>前回の初級編の復習として活用する

Gitはスナップショットを記録する（差分ではない）  
理由：ブランチを切ったりマージしたりするから

バージョン管理（コミット）することで以前の状態に戻せる

---

## 14 Gitの操作の流れを掴もう

>これも前回の初級編の復習として活用する

流れ | 内容
:--- | :---
1 | 自分のPC（ローカルリポジトリ）でスナップショットを記録
2 | GitHub（リモートリポジトリ）へアップロード

ローカルは3つのエリアに分かれている  

流れ | 名称 |　内容
:--- | :--- | :---
1 | ワークツリー | ファイルを変更する作業場
2 | ステージ | コミットする変更を準備（git add）
3 | ローカルリポジトリ | スナップショットを記録（git commit）

---

## 15 Gitってどのようにデータを管理しているのか

データのデータ構造はどのようになっているのか？  
裏側ではどのような動きをしているのか？  

リポジトリには、以下3種類のファイルが作られている  
（コミットまでの流れ）

流れ | 名称 |　内容
:--- | :--- | :---
1 | 圧縮ファイル | ファイル内容を圧縮したもの
2  | ツリー1| ファイル構成を記録したもの
3  | コミット1 | ツリー1、作成者、日付、コミットメッセージ

---

## 16 Gitはどのようにデータを管理しているのか2

- リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成することでデータを保存している。

- コミットが親コミットを持つことで変更履歴をたどることができる。

- Gitの本質はデータを圧縮して、スナップショットで保存していること。

---

## 17 Gitのデータ管理の補足

### Gitオブジェクト

git addやgit commitした時に作られるファイル（3種類）  
「.git/objects」ディレクトリの下に保存されます

#### blob（ブロブ）オブジェクト

blob（ブロブ）というのはカタマリという意味  
ファイルの中身を圧縮しただけのカタマリということ  
ファイル名はハッシュID  
ヘッダー（ファイル内容の文字数など、ファイルのメタ情報）とファイル内容を、SHA-1というハッシュ関数で40文字の英数字に変換したもの  
ハッシュIDのうち、先頭2文字をディレクトリ名に、残り38文字をファイル名にして保存します  

- ハッシュIDの確認方法

    ```bash
    $git hash-object second.md
    ```

#### treeコマンドのインストール方法

＜Macの場合＞

- Homebrewを使ってインストールする。

    ターミナルで下記コマンドを実行する。

    ```bash
    $brew install tree
    ```

- ファイル構造を表示

    ```bash
    $tree .git
    ```

- masterブランチ上での最後のコミットが指しているツリーファイルの中身を表示

    ```bash
    $git cat-file -p master^{tree}
    ```

---

## 18 Gitを始めよう

### ローカルリポジトリの作成

- ターミナルを開く

- プロジェクトのディレクトリ作成

    ```bash
    $cd ~/desktop
    $mkdir udemy_code
    $cd udemy_code
    $mkdir git_tutorial
    ```

- ディレクトリに移動

    ```bash
    $cd git_tutorial
    ```

- ローカルリポジトリの作成

    .gitディレクトリが作成される
    （リポジトリ、インデックスファイル、設定ファイル）

    ```bash
    $git init
    ```

---

### GitHub上にあるプロジェクトから始めよう

- Gitリポジトリのコピーを作成する

    ファイルと.gitディレクトリがコピーされる

    ```bash
    $git clone "コピー"
    ```

    例：GitHubにあるAtomのデータをコピーしてみる
    <https://github.com/atom/atom>

    ```bash
    $cd ~/desktop/test_git
    $git clone https://github.com/atom/atom.git
    ```

    100%になったら、ちゃんと落ちているかを確認する

    ```bash
    $cd atom
    $ls -a
    ```

---

## 20 変更をステージに追加しよう

ステージはなぜあるのか？  
コミットする変更を準備するため  

- 変更をステージに追加する

    ```bash
    $git add <ファイル名>
    $git add <ディレクトリ名>
    $git add .
    ```

---

## 21 変更を記録しよう

- 変更を記録すること＝コミット

    ```bash
    $git commit
    $git commit -m "<メッセージ>" #メッセージをターミナルから
    $git commit -v #Gitが立ち上がる　変更・新規作成・削除・二数ファイルの変更、作成、削除
    ```

- わかりやすいコミットメッセージを書く
  - 変更内容の要点と理由を一行で簡潔に書く
  - 正式に書く時
    - 1行目：変更内容の要約
    - 2行目：空行
    - 3行目：変更した理由

>Udemyで紹介しているAtomではなくVSCodeで対応しているので動画と動きが異なる・・・  
だいたい把握できているので大丈夫ということにして先に進む  

---

## 22 現在の変更状況を確認しよう

- コミットやステージに追加する前にどのファイルが変更されたかを確認する癖をつける

- 現在の変更状況を確認（ステージにあげる必要があるかないか）

    ```bash
    $git status
    ```

- ファイルを変更したら、ステージに追加する

    ```bash
    $git add <ファイル名>
    ```

- 現在の変更状況を確認する(addちゃんとできているか)

    ```bash
    $git status
    ```

- コミットする

    >エディタをAtomからVSCodeに変更したため、動画と動作が異なるが把握しているので問題なし

---

## 23 何を変更したのかを確認しよう

- コミットやステージに追加する前にどんな変更したかを確認する

- 変更差分を確認する

    ```bash
    #git addする前の変更分
    $git diff
    $git diff <ファイル名>

    #git ステージとコミットとの間のファイルの変更点
    $git diff --staged
    ```

---

## 24 変更履歴を確認しよう

- 以前どのような変更があったのか？と昔のことを調べたいとき
  - 変更履歴を確認する

    ```bash
    $git log

    #一行で表示する
    $git log --oneline

    #ファイルの変更差分を表示する
    $git log -p <ファイル名>

    #表示するコミット数を制限する
    $git log -n <コミット数>
    ```

---

## 25 ファイルの削除を記録しよう

- ファイルの削除を記録するには、git addとは別のコマンド
  - ファイルの削除を記録する

    ```bash
    #ファイルごと削除
    $git rm <ファイル名>
    $git rm -r <ディレクトリ名>

    #リポジトリだけ削除　ワークツリーには残す
    $git rm --cached <ファイル名>

    #削除したファイルを元に戻す
    $git reset HEAD <ファイル名>
    $git checkout <ファイル名>

    #削除や変更したら以下をして内容確認する
    $git status
    $ls
    ```

---

## 26 ファイルの移動を記録しよう

- ファイルの移動を記録する

  ```bash
  $git mv <旧ファイル> <新ファイル>
  #例：$git mv index.html index2.html
  
  #以下のコマンドと同じ（通常のコマンドでも代替可能）
  $mv <旧ファイル> <新ファイル>
  $git rm <旧ファイル>
  $git add <新ファイル>
  ```

---

## 27 GitHubにプッシュしよう

- コミットしたら、その内容をGitHubにアップする
  - リモートリポジトリ（GitHub）を新規追加する

    ```bash
    #originというショートカットでurlのリモートリポジトリを登録
    $git remote add origin <htmls://github.com/user/repo.git
    ```

  - リモートリポジトリ(GitHub)へ送信する

    ```bash
    #ローカルリポジトリの内容をリモートリポジトリに送る＝プッシュ
    $git push <リモート名> <ブランチ名>
    $git push origin master

    #以下にすると今後 origin masterを入力しなくてすむ
    $git push -u origin master
    ```

---

## 28 GitHubの画面を確認しよう

>だいたい初級編で学んだことと一緒だったので割愛

---

## 29 コマンドにエイリアスをつけよう

- コマンドの入力を短縮して入力を楽にしょう
  - コマンドにエイリアスをつける
  
    ```bash
    #--globalをつけるとPC全体の変更となる
    $git config --global alias.ci commit
    $git config --global alias.st status
    $git config --global alias.br branch
    $git config --global alias.co checkout

    #登録されているエイリアスを表示させる
    $git alias
    ```

---

## 30 バージョン管理しないファイルは無視しよう

- バージョン管理したくないファイルとは？
  - パスワードなどの秘密情報が入っているファイル
  - チームの開発に不要なファイル（キャッシュ、自動生成されるファイル）

- 管理しないファイルをGitの管理から外す
  - .gitignoreファイルに指定する

    ```bash
    #指定したファイルを除外
    index.htnl

    #ルートディレクトリを指定
    /root.html

    #ディレクトリ以下を除外
    dir/

    #/以外の文字列にマッチ「*」
    /*/*.css
    ```
  
    ```bash
    #空ファイルの作成方法（secret.txt）
    $touch secret.txt
    ```

  - エディターで「.gitignoreファイル」を作成する
    - ファイルの中に管理したくないファイル名を入力
      例：secret.txt
    - ファイル名を.gitignoreファイルとして保存
      非表示のファイルとなる

---

## 小テスト1：本章の復習

>テスト 問題なし

---

## 31 ファイルへの変更を元に戻そう

- ワークツリーのファイルを元の状態に戻したいとき
  - ファイルへの変更を取り消す
    ステージにあるファイルをワークツリーのファイルへもってきてくれて反映してくれる  

    ```bash
    #"--"とつけているのは、ブランチ名とファイル名がかぶったときに、どちらを指しているのかGitがわからなくなるのを避けるため

    $git checkout -- <ファイル名>
    $git checkout -- <ディレクトリ名>

    #全変更を取り消す
    $git checkout -- .
    ```

    >ちなみにcheckoutのエイリアスはco  
    すごい便利だ！これは活用していきたい。

---

## 32 ステージした変更を取り消そう

- ステージに変更したけど元に戻したいときに利用する
  （git addしたけど取り消したい）
  ステージへの取り消しだけなので、ワークツリーも元に戻したい場合は`git checkout`で、もとに戻すこと  
  最新のコミットした内容をステージに上書きしている  

  ```bash
  #注意：変更をステージから取り消すだけ ローカルには影響がない
  $git reset HEAD <ファイル名>
  $git reset HEAD <ディレクトリ名>

  #全変更を取り消す
  $git reset HEAD .
  ```
  
---

## 33 直前のコミットをやり直そう

- 例：
  - なにか変更をコミットし忘れた
  - コミットメッセージをやり直ししたい  

  今のステージにある内容を元にコミットを上書きして直前のコミットを修正している  
  リモートリポジトリにPushしたコミットはやり直したらダメ  
  なぜなら、他の人が落としている可能性があるから  
  Pushした内容を修正したい場合は、もう一度コミットしてPushして修正すること  

  ```bash
  $git commit --amend
  ```

  >実際に動かしてみたところ、ターミナルで行うとエラーがでる。VSCodeでやれと出てくるので、そちらで確認し問題なさそうだった。

---

## 小テスト2：本章の復習

>何ら問題なく回答できた

---

## 34 リモートの情報を確認しよう

- リモートを表示する

  ```bash
  #登録してあるリモート名しか表示されない
  $git remote

  #対応するURLを表示 フェッチとプッシュが見れる
  $git remote -v
  ```

---

## 35 リモートリポジトリを追加しよう

- リモートリポジトリは複数登録することができる
  - チーム開発とは別に自分でも持っておきたい場合
  - 複数のチームでそれぞれでリポジトリを持っている場合

- リモートリポジトリを新規追加する

  ```bash
  $git remote add <リモート名> <リモートURL>
  
  #例：tutorialというショートカットでurlのリモートリポジトリを登録する
  $git remote add tutorial https://github.com/user/repo.git
  ```

- リモートリポジトリを切り替える

  ```bash
  $git push <リモート名> master

  #例：リモート名がtutorial
  $git push tutorial master

  #tutorialを今後のデフォにしたい場合は
  $git push -u tutorial master

  #上記をやれば、今後は以下だけでプッシュできる
  $git push
  ```

---

## 36 リモートから取得しよう（フェッチ編）

- リモートから情報を取得するには2種類の方法がある
  - フェッチ
  - プル

- リモートから情報を取得する（フェッチ）
  フェッチは、リモートリポジトリからローカルリポジトリへとってくる  
  ワークツリーには反映されない  
  フェッチ＝「とってくる」という意味

  ```bash
  #remotes/リモート/ブランチ に保存される
  $git fetch <リモート名>
  $git fetch origin

  #落ちているかの確認
  $git branch -a

  #落としてきたファイルをチェックする
  $git checkout remotes/origin/master

  #中身を確認
  $ls

  #新規で追加したファイルの中身確認
  $cat home.html

  #元のワークツリーに戻す
  $git checkout masuter

  #中身の確認
  $ls

  #落としてきたファイルをワークツリーに反映させる
  $git merge origin/master

  #ここでコミットメッセージを入れると動画にあるがでてこなかった

  #中身の確認
  $ls
  ```
  
  ワークツリーへの反映の方法は別の章で学習する

---

## 37 リモートから取得しよう（プル編）

- リモートから情報を取得するには2種類の方法がある
  - フェッチ
  - プル

- リモートから情報を取得する（プル）
  プルは、リモートから情報を取得してマージまでを一度にやりたいとき  
  ワークツリーに反映される  
  プル＝「ひっぱってくる」という意味

  ```bash
  $git pull <リモート名> <ブランチ名>
  $git pull origin master

  #下記コマンドに省略すると $git pull origin masterと同意
  $git pull

  #これは下記コマンドと同じこと
  $git fetch origin master
  $git merge origin/master
  ```

---

## 38 フェッチとプルを使い分けよう

- リモートから情報を取得するには2種類の方法がある
  - フェッチ
  - プル

- どのように使い分けしたらいいのか？
  フェッチを基本的に使うのがおすすめ  
  プルは楽だが挙動が特殊なので気をつける必要がある

- プルの注意点
  - 2種類のリポジトリがあった場合、違うブランチにマージされる可能性がある
  - ちゃんと理解しているならプルでよいが、慣れるまではフェッチで対応したほうが安全

---

## 39 リモートの情報を詳しく知ろう

- リモートの詳細情報を表示する

  ```bash
  #git remoteコマンドより詳しい情報を表示する
  $git remote show <リモート名>
  $git remote show origin
  ```

---

## 40 リモートを変更・削除しよう

- 例：
  - 別のリモート名を使いたくなったとき
  - リモートを使わなくなったとき

- リモートを変更

  ```bash
  $git remote rename <旧リモート名> <新リモート名>
  
  #例：
  $git remote rename tutorial new_tutorial
  ```

- リモートを削除

  ```bash
  $git remote rm <リモート名>

  #例：
  $git remote rm new_tutorial
  ```

---

## 小テスト3：本章の復習

>何ら問題なく解答できたので次に進む

---

## 41 ブランチってなに

- マージとは
  他の人が開発した変更を自分のところへ取り込むこと

- ブランチとは
  並行して複数機能を開発するためにあるもの
  他の人の変更を影響受けない

---

## 42 ブランチの仕組みを知ろう

- Gitのデータの持ち方
  リポジトリの中身
  - 圧縮ファイルA
  - ツリー1
  - コミット1

- コミット名
  ハッシュ関数40文字程度の英数字

- ブランチはコミットを指したポインタ

- HEADとは、自分が今作業しているブランチを指し示したポインタ

- コミットしたらブランチが指すコミットファイルが変わる

- ブランチとHEADの中身
  ブランチはコミットIDを記録したポインタ
  HEADはref:future （現在作業中のブランチへのポインタ）

- ファイルの場所（リポジトリの中に記憶されている）
  - HEAD : .git/head
  - ブランチ（master, feature) : .git/refs/

- ブランチの仕組みのまとめ
  - 分岐することで複数の機能を同時並行で開発するための仕組みがブランチ
  - ブランチとはコミットを指すポインタ
  - ブランチの作成や切り替え、マージが他のバージョン管理ツールより高速
  - 結果、Gitは大規模開発において最も使われるツールとなり、普及した

---

## 43 新しいブランチを作成しよう

- ブランチを新規追加する

  ```bash
  #ブランチを作成するだけで、HEADは元の場所のまま
  $git branch <ブランチ名>
  
  #例：
  $git branch feature
  ```

- ブランチの一覧を表示する

  ```bash
  #今いるブランチには「*」印がつく
  $git branch

  #全てのブランチを表示する（リモートリポジトリも表示される）
  $git branch -a
  
  #それぞれのブランチがどのコミットを指しているかの確認
  $git log --oneline --decorate
  ```

---

## 44 ブランチを切り替えよう

- ブランチを切り替える

  ```bash
  $git checkout <既存ブランチ名>

  #例：
  $git checkout feature

  #ブランチを新規作成・切り替える（一度にできるので楽）
  $git checkout -b <新ブランチ名>
  ```

---

## 45 変更をマージしよう

- マージとは
  他の人の変更内容を取り込み作業のこと

- 変更履歴をマージする

  ```bash
  #作業中のブランチにマージする
  $git merge <ブランチ名>
  $git merge <リモート名/ブランチ名>

  #例：
  $git merge origin/master
  ```

- マージには3種類ある
  - Fast Foward：早送りになるマージ
    ブランチが枝分かれしていなかったときはブランチのポインタを前にすすめるだけ
  - Auto Merge：基本的なマージ
    枝分かれして開発していた場合、マージコミットという新しいコミットを作る
  - コンフリクト：次回やる

---

## 46 コンフリクトを解決しよう

- 複数人の人が同じ箇所で別々の変更をしたときにどの変更を優先したらいいかわからないという状態

- コンフリクトはどのような時に起こるのだろうか？
  - 同じファイルの同じ行に対して異なる編集を行ったとき

- コンフリクトの解決の仕方
  - コンフリクトしたファイル
    <<HEAD〜 == ：HEADの部分  
    == 〜 >>feature ： featureの部分  

    ```html
    <h1>Gitチュートリアル</h1>
    <p>ようこそ</p>
    <<<<<<<< HEAD
    <p>git addについて学ぼう</p>
    ======
    <p>git commitを知ろう</p>
    >>>>>>>> feature
    ```

  - 解決したファイル
    1. ファイルの内容を書き換える
    2. 「<<」「==」「>>」の記述を削除する

    ```html
    <h1>Gitチュートリアル</h1>
    <p>ようこそ</p>
    <p>git addについて学ぼう</p>
    <p>git commitを知ろう</p>
    ```

  - コンフリクトを起こしたファイルがなにかを調べる

    ```bash
    $git status
    ```

  - コンフリクトを解決したときのコメント  
    3行目に「コンフリクトの解決」を追加するとわかりやすい

---

## 47 コンフリクトが起きないようにするにはどうすればいよいか

- コンフリクト関連の事故が起きにくい運用ルール
  - 複数人で同じファイルを変更しない
  - pullやmergeする前に変更中の状態をなくしておく
    （commitやstashをしておく）
  - pullするときは、pullするブランチに移動してからする
  - コンフリクトしても慌てない

---

## 48 ブランチを変更・削除しよう

- ブランチ名を変更

  ```bash
  #自分が作業しているブランチの名前を変更する
  $git branch -m <ブランチ名>
  
  #例：
  $git branch -m new_branch
  ```

- ブランチを削除

  ```bash
  #masterにマージされていない変更が残っている場合削除しないでくれる
  $git branch -d <ブランチ名>
  
  #例：
  $git branch -d feature

  #強制削除する（マージされてなくても消せる）
  $git branch -D <ブランチ名>
  ```

---

## 49 ブランチを利用した開発の流れ

- masterブランチをリリース用ブランチに、開発はトピックブランチを作成して進めるのが基本

- masterブランチでは開発しない＝リリース専用ブランチ

- 開発はトピックごとに最新のmasterからブランチを切る
  開発が終わったらトピックブランチをmasterにマージしリリース
  masterを最新のものにできる

---

## 50 リモートブランチとは

- リモートブランチとは
  リモートのブランチの状態へのポインタ

- リモートブランチは<リオモート>/<ブランチ>で参照できる

  ```bash
  #リモートリポジトリのブランチを取得する
  $git fetch

  #ブランチを確認する
  $git branch -a

  ---

## 小テスト4：本章の復習

>問題なし

---

## 51 プルリクエストの流れ

### プルリクエストとは

自分の変更したコードをリポジトリに取り込んでもらえるよう依頼すること
取り込む前にレビューしてもらうための機能

- バグを発生させないため
- コードの質を保つため

### プルリクエストの手順

1. ローカル：masterブランチを最新に更新
2. ローカル：ブランチを作成
3. ローカル：ファイルを変更
4. ローカル：変更をコミット
5. ローカル：GitHubへプッシュ
6. GitHub：プルリクエストを送る
7. GitHub：コードレビュー
8. GitHub：プルリクエストをマージ
9. GitHub：ブランチを削除

### 例

```bash
#自分がどのブランチにいるか確認する（master）
$git branch

#ローカルの内容を最新の情報に変更する
$git pull origin master

#最新の状態になっているか念のため確認する
$git status

#新しいブランチを作成し、移動する
$git checkout -b pull_request

#自分がどのブランチにいるか確認する（master）
$git branch

#ファイルの変更を加える（テキストエディタでなにかしらのファイル 今回はhome.html）

#変更分をステージにaddする
$git add home.index

#変更をコミットする（コメントを入れる）
$git commit

#プッシュする
$git push origin pull_request
```

- GitHubへ移動
  - プルリクエストボタンを押す
  - 「new pull request」ボタンを押す
  - baseは「master」、compareに「purr_request」
  - 「Create pull request」ボタンを押す
  - タイトルを入力「例：pull requestを追記」
  - 本文を入力「例：レビューお願いします」
  - 「Create purr request」ボタンを押す
  - コードレビュー依頼「Reviewers」を追加（メールで通知行く）
- レビュアーはなにをするか
  - プルリクエストボタンを押す
  - 「pull requestを追記」をクリックし内容を確認する
  - 修正してほしい行の横にプラスポタンが出てコメント追加できる
    「Add single comment」で追加
  - すべて確認が終わったら、「Review changes」を押す
  - 「Approve」ボタンを押す（一人開発だと不可）
  - 「Submit review」ボタンを押す
  - 「Conversation」をクリック
  - 「Merge pull request」ボタンを押す
  - 「Confirm merge」ボタンを押す
  - 「Delete branch」ボタンを押して不要なブランチを削除

```bash
#masterブランチに切り替える
$git checkout master

#自分がどのブランチにいるか確認する（master）
$git branch

#マージされた内容をローカルに落とす
$git pull origin master

#不要なブランチを削除
$git branch -d pull_request
```

---

>今後の更新は練習のためブランチを作成し、そちらで修正しプルリクエストしての流れで更新していく

## 52 GitHub Flowの流れ

- GitHub Frowとは「GitHub社のワークフロー」
  1. ローカル：masterブランチからブランチを作成
  2. ローカル：ファイルを変更しコミット
  3. ローカル：同名のブランチをGitHubへプッシュ
  4. GitHub：プルリクエストを送る
  5. GitHub：コードレビューし、masterブランチにマージ
  6. GitHub：masterブランチをデプロイ（リリースする）

- GitHub Flowを実践する上でのポイント
  - masterブランチは常にデプロイできる状態に保つ
  - 新開発はmasterブランチから新しいブランチを作成してスタート
  - 作成した新しいブランチ上で作業しコミットする
  - 定期的にプッシュする
  - masterにマージするためにプルリクエストを使う
  - 必ずレビューを受ける
  - masterブランチにマージしたらすぐにデプロイする
    テストとデプロイ作業は自動化

- なぜこのやり方なのか？
  - 開発フローをシンプルに保つ
  - リリースされているものがすぐにわかる
  - バグがあっても機能単位で開発しているのでやり直しやすい

---

## 53 GitHub Flowを実践しよう

- GitHub Frowとは「GitHub社のワークフロー」
  1. ローカル：masterブランチからブランチを作成
  2. ローカル：ファイルを変更しコミット
  3. ローカル：同名のブランチをGitHubへプッシュ
  4. GitHub：プルリクエストを送る
  5. GitHub：コードレビューし、masterブランチにマージ
  6. GitHub：masterブランチをデプロイ（リリースする）

>今後、このsecond.mdファイルを更新する際、上記のフローにのっとって対応していく

---

## 54 リベースする

### リベースとは

マージの他にリベースがある
変更を統合する際に、履歴をきれいに整えるために使うもの

### リベースの一連の作業の流れ

- ブランチ（feature）に移動

  ```bash
  $git checkout <ブランチ名>
  
  #例：
  $git checkout feature
  ```

- ブランチの起点となるコミットを別のコミットに移動する

  ```bash
  $git rebase <ブランチ名>

  #例：
  $git rebase feature
  ```

- ブランチ（master）に移動

  ```bash
  $git checkout <ブランチ名>

  #例：
  $git checkout master
  ```

- マージする

  ```bash
  $git merge <ブランチ名>
  
  #例：
  $git checkout feature
  ```

- 例：

  ```bash
  #最新の状態になっているか念のため確認する
  $git status

  #自分がどのブランチにいるか確認する（master）
  $git branch

  #featureブランチを作成する
  $git branch feature

  #ブランチなにがあるか確認する（featureあるか）
  $git branch

- VSCodeへ移動
  - 新規で「master2.html」ファイルを作成保存

- ターミナルへ移動

  ```bash
  #ステージに上げる
  $git add master2.html

  #変更をコミットする（コメントを入れる）
  $git commit

  #ブランチをfeatureに切り替える
  $git checkout feature
  ```

- VSCodeへ移動
  - 新規で「feature2.html」ファイルを作成保存

- ターミナルへ移動

  ```bash
  #ステージに上げる
  $git add feature2.html

  #変更をコミットする（コメントを入れる）
  $git commit

  #リベースする
  $git rebase master

  #リベースできたか確認する
  $git log

  #ブランチをmasterに切り替える
  $git checkout master

  #マージする
  $git merge feature

  #プッシュする
  $git push origin master

  #ブランチなにがあるか確認する（featureがあるか）
  $git branch

  #不要なブランチを削除
  $git branch -d feature
  ```

---

## 55 リベースでしてはいけないこと

- GitHubにプッシュしたコミットをリベースするのはNG
  - ローカルとGitHubの情報が異なるのでpushできなくなる
- git push -f は絶対NG
  - このコマンドを使うと強制的にやれるが履歴が壊れる

---

## 56 リベースとマージのどちらを使うのか

- マージかリベースかは考え方次第

- マージ→作業の履歴を残したい場合
  - ○：コンフリクトの解決が比較的カンタン
  - ☓：マージコミットがたくさんあると履歴が複雑化する

- リベース→履歴をきれいにしたい
  - ○：履歴をきれいに保つことができる
  - ☓：コンフリクトの解決が若干面倒
        （コミットそれぞれに解消が必要）

- マージとリベースのコンフリクトの違い
  - マージではコンフリクトは一度しか発生しない
  - リベースは各コミットごとに発生する

### まとめ

- プッシュしていないローカルの変更にはリベースを使う
- プッシュしたあとはマージを使う
- コンフリクトしそうならマージを使う
  - チームで開発していて他の人がなにをしているか把握できている
  - ローカルをプルリクエストをすると、コンフリクトのアラートだしてくれる
- 変更内容をとりこんだ履歴をちゃんと残したいとき

---

## 57 プルの設定をリベースに変更する

### プルには2つの型がある

- マージ型
- リベース型

### どのように違うのか

- プルのマージ型
  マージコミットが残るから、マージしたという記録を残したい場合

  ```bash
  $git pull <リモート名> <ブランチ名>

  #例：
  $git pull origin master
  ```

- プルのリベース型
  マージコミットが残らないので、GitHubの内容を取得したいだけの時はこちら

  ```bash
  $git pull --rebase <リモート名> <ブランチ名>

  #例：
  $git pull --rebase origin master
  ```

- プルをリベース型に設定する

  ```bash
  $git config --global pull.rebase true

  #例：masterブランチでgit pullする時だけ
  $git config branch.master.rebase true
  ```

---

## 58 リベースで履歴を書き換えるその1

- コミットをきれいに整えてからプッシュしたいときは履歴を書き換えよう
  ※GitHubにプッシュしていないコミット

### 直前のコミットをやり直す

  ```bash
  #リモートリポジトリにプッシュしたコミットはダメ
  $git commit --amend
  ```

### 複数のコミットをやり直す

  ```bash
  #-iは、「interactive」対話的なリベース
  $git rebase -i <コミットID>

  #例：直前3つ分表示される
  $git rebase -i HEAD~3

  pick gh21f6d ヘッダー修正
  pick 193054e ファイル追加
  pick 84gha0d README修正
  ```

  ```bash
  #やり直したいcommitをeditにする
  edit gh21f6d ヘッダー修正
  pick 193054e ファイル追加
  pick 84gha0d README修正

  #やり直したら実行する
  $git commit --amend

  #次のコミットへ進む（リベース完了）
  $git rebase --continue
  ```

### コミットの指定の方法

- HEAD~ （チルダ）
  一番目の親を指定する。  
  HEADを基点にして数値分の親コミットまで指定する  

- HEAD^ （キャレット）
  マージした場所の2番目の親を指定する  

### rease -i コマンドの一連の流れ

1. git rebase -iコマンドで対話的リベースモードに入る
2. 修正したコミットをeditにしてコミットエディタを終了する
3. editのコミットのところでコミットの適用が止まる
4. git commit --amendコマンドで修正
5. git rebase --continueで次のコミットへいく
6. pickだとそのままのコミット内容を適用して次へいく

### 練習

```bash
#first.htmlという名前の空ファイルを作成する
touch first.html

```

---

## 59 リベースで履歴を書き換える

### コミットを並び替える、削除する

  ```bash
  #履歴は古い順に表示されるので注意 git logとは逆
  $git rebase -i HEAD~3

  pick gh21f6d ヘッダー修正
  pick 193054e ファイル追加
  pick 84gha0d README修正
  ```

  ```bash
  #1.84gha0dのコミットを消す
  #2.193054eを先に適用する

  pick 193054e ファイル追加
  pick gh21f6d ヘッダー修正
  ```

### コミットをまとめる

  ```bash
  #履歴は古い順に表示されるので注意 git logとは逆
  $git rebase -i HEAD~3

  pick gh21f6d ヘッダー修正
  pick 193054e ファイル追加
  pick 84gha0d README修正
  ```

  ```bash
  #squashを指定するとそのコミットを直前のコミットとまとめる

  pick gh21f6d ヘッダー修正
  squash 193054e ファイル追加
  squash 84gha0d README修正
  ```

### コミットを分割する

  ```bash
  #履歴は古い順に表示されるので注意 git logとは逆
  $git rebase -i HEAD~3

  pick gh21f6d ヘッダー修正
  pick 193054e ファイル追加
  pick 84gha0d READMEとindexを修正
  ```

  ```bash
  #コミットを分割する
  pick gh21f6d ヘッダー修正
  pick 193054e ファイル追加
  edit 84gha0d READMEとindexを修正

  #ステージングしていない状態に戻す
  $git reset HEAD^

  $git add README
  $git commit -m "README修正"
  $git add indeh.html
  $git commit -m "index.html修正"
  $git rebase --continue
  ```

---

## タグの一覧を表示する

### タグとはなにか

  コミットを参照しやすくするためにわかりやすい名前をつけること  
  よくリリースポイントに使う  

### タグの一覧を表示

  ```bash
  #git tagコマンドはアルファベット順にタグを表示する
  $git tag

  #パターンを指定してタグを表示
  $git tag -l "201705"
  20170501_01
  20170501_02
  20170503_01
  ```

---
